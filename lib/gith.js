// Generated by CoffeeScript 1.8.0
(function() {
  var EventEmitter2, Gith, debug, filterSettings, http, listen, querystring, util, _;

  http = require("http");

  EventEmitter2 = require("eventemitter2").EventEmitter2;

  util = require("util");

  _ = require("lodash");

  querystring = require("querystring");

  debug = require("debug")("gith:");

  filterSettings = function(settings, payload) {
    var checksPassed;
    debug('settings:', settings);
    if (!payload) {
      return false;
    }
    settings = settings || {};
    payload.matches = {};
    checksPassed = true;
    ["repo", "branch", "file", "tag"].forEach(function(thing) {
      var checks, passed, wat;
      wat = settings[thing];
      passed = true;
      if (wat && wat !== "*") {
        passed = false;
        checks = [].concat((thing === "file" ? payload.files.all : payload[thing]));
        passed = checks.some(function(check) {
          var match;
          if (wat === check) {
            return true;
          }
          if (_.isString(wat) && wat[0] === "!" && wat.slice(1) !== check) {
            return true;
          }
          if (_.isRegExp(wat)) {
            match = check.match(wat);
            if (match) {
              if (thing === "file") {
                if (!payload.matches.files) {
                  payload.matches.files = {};
                }
                payload.matches.files[check] = match;
              } else {
                payload.matches[thing] = match;
              }
              return true;
            }
          }
        });
        if (_.isFunction(wat)) {
          passed = wat(payload[thing], payload);
        }
        checksPassed = passed && checksPassed;
      }
    });
    debug(checksPassed);
    return checksPassed;
  };

  Gith = function(eventaur, settings) {
    var gith;
    gith = this;
    this.settings = settings || {};
    EventEmitter2.call(this, {
      delimiter: ":",
      maxListeners: 0
    });
    eventaur.on("payload", function(originalPayload) {
      var payload;
      payload = gith.simplifyPayload(originalPayload);
      if (filterSettings(settings, payload)) {
        payload.deploy = settings.deploy;
        gith.emit("all", payload);
        if (originalPayload.created && originalPayload.forced && payload.branch) {
          gith.emit("branch:add", payload);
        }
        if (originalPayload.deleted && originalPayload.forced && payload.branch) {
          gith.emit("branch:delete", payload);
        }
        if ((originalPayload.commits != null) && payload.branch) {
          gith.emit("branch:commits", payload);
        }
        if (payload.files.added.length > 0) {
          gith.emit("file:add", payload);
        }
        if (payload.files.deleted.length > 0) {
          gith.emit("file:delete", payload);
        }
        if (payload.files.modified.length > 0) {
          gith.emit("file:modify", payload);
        }
        if (payload.files.all.length > 0) {
          gith.emit("file:all", payload);
        }
        if (payload.tag && originalPayload.created) {
          gith.emit("tag:add", payload);
        }
        if (payload.tag && originalPayload.deleted) {
          gith.emit("tag:delete", payload);
        }
      }
    });
  };

  util.inherits(Gith, EventEmitter2);

  Gith.prototype.simplifyPayload = function(payload) {
    var branch, owner, rRef, refMatches, simpler, tag;
    payload = payload || {};
    branch = "";
    tag = "";
    rRef = /refs\/(tags|heads)\/(.*)$/;
    refMatches = (payload.ref || "").match(rRef);
    if (refMatches) {
      if (refMatches[1] === "heads") {
        branch = refMatches[2];
      }
      if (refMatches[1] === "tags") {
        tag = refMatches[2];
      }
    }
    if (!branch && payload.base_ref) {
      branch = payload.base_ref.replace(rRef, "$2");
    }
    owner = payload.repository.url.match(/\/(\w+)\//)[1];
    simpler = {
      original: payload,
      files: {
        all: [],
        added: [],
        deleted: [],
        modified: []
      },
      tag: tag,
      branch: branch,
      repo: (payload.repository ? owner + "/" + payload.repository.name : null),
      sha: payload.after,
      time: (payload.repository ? payload.repository.pushed_at : null),
      urls: {
        head: (payload.head_commit ? payload.head_commit.url : ""),
        branch: "",
        tag: "",
        repo: (payload.repository ? payload.repository.url : null),
        compare: payload.compare
      },
      reset: !payload.created && payload.forced,
      pusher: (payload.pusher ? payload.pusher.name : null),
      owner: owner
    };
    if (branch) {
      simpler.urls.branch = simpler.urls.branch + "/tree/" + branch;
    }
    if (tag) {
      simpler.urls.tag = simpler.urls.head;
    }
    (payload.commits || []).forEach(function(commit) {
      _.each({
        added: "added",
        modified: "modified",
        removed: "deleted"
      }, function(s, g) {
        simpler.files[s] = simpler.files[s].concat(commit[g]);
        simpler.files.all = simpler.files.all.concat(commit[g]);
      });
    });
    debug(simpler);
    return simpler;
  };

  listen = function(eventaur, port) {
    if (port) {
      this.port = port;
    }
    if (!this.port) {
      throw new Error(".listen() requires a port to be set");
    }
    this.server = http.createServer(function(req, res) {
      var data;
      data = "";
      if (req.method === "POST") {
        req.on("data", function(chunk) {
          data += chunk;
        });
      }
      req.on("end", function() {
        var payload;
        debug(JSON.stringify(JSON.parse(data), null, 2));
        payload = JSON.parse(data);
        eventaur.emit("payload", payload);
        res.writeHead(200, {
          "Content-type": "text/html"
        });
        res.end();
      });
    }).listen(port);
  };

  module.exports = function(port) {
    return module.exports.create(port);
  };

  module.exports.create = function(port) {
    var eventaur, ret;
    eventaur = new EventEmitter2({
      delimter: ":",
      maxListeners: 0
    });
    ret = function(map) {
      return new Gith(eventaur, map);
    };
    ret.listen = listen.bind(ret, eventaur);
    ret.close = function() {
      this.server.close();
    };
    ret.payload = function(payload) {
      eventaur.emit("payload", payload);
    };
    if (port) {
      ret.listen(port);
    }
    return ret;
  };

}).call(this);

//# sourceMappingURL=gith.js.map
